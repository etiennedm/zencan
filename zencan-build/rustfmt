use crossbeam :: atomic :: AtomicCell ; use core :: cell :: RefCell ; use critical_section :: Mutex ; # [allow (unused_imports)] use zencan_common :: objects :: { CallbackObject , ODEntry , ObjectData , ObjectRawAccess , SubInfo } ; use zencan_common :: sdo :: AbortCode ; # [derive (Debug , Default)] pub struct Object2000 { pub size : u8 , pub array : Mutex < RefCell < [u32 ; 2usize] >> } impl Object2000 { pub fn set (& self , idx : usize , value : u32) -> Result < () , AbortCode > { if idx >= 2usize { return Err (AbortCode :: NoSuchSubIndex) } critical_section :: with (| cs | { let mut array = self . array . borrow_ref_mut (cs) ; array [idx] = value ; }) ; Ok (()) } pub fn get (& self , idx : usize) -> Result < u32 , AbortCode > { if idx >= 2usize { return Err (AbortCode :: NoSuchSubIndex) } let value = critical_section :: with (| cs | { let array = self . array . borrow_ref (cs) ; array [idx] }) ; Ok (value) } } impl ObjectRawAccess for Object2000 { pub fn write (& self , sub : u8 , offset : usize , data : & [u8]) -> Result < () , AbortCode > { if sub == 0 { return Err (AbortCode :: ReadOnly) ; } if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } let value = u32 :: from_le_bytes (data . try_into () . map_err (| _ | { if data . len () < size_of :: < u32 > () { AbortCode :: DataTypeMismatchLengthLow } else { AbortCode :: DataTypeMismatchLengthHigh } }) ?) ; self . set ((sub - 1) as usize , value) ; Ok (()) } pub fn read (& self , sub : u8 , offset : usize , buf : & mut [u8]) -> Result < () , AbortCode > { if sub == 0 { if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } if buf . len () != 1 { return Err (AbortCode :: DataTypeMismatchLengthHigh) ; } buf [0] = 2usize as u8 ; return Ok (()) } if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } let value = self . get ((sub - 1) as usize) ? ; if buf . len () < size_of :: < u32 > () { return Err (AbortCode :: DataTypeMismatchLengthLow) ; } if buf . len () > size_of :: < u32 > () { return Err (AbortCode :: DataTypeMismatchLengthHigh) ; } buf . copy_from_slice (& value . to_le_bytes ()) ; Ok (()) } pub fn sub_info (& self , sub : u8) -> Result < SubInfo , AbortCode > { if sub == 0 { return Ok (SubInfo { access_type : zencan_common :: objects :: AccessType :: Ro , data_type : zencan_common :: objects :: DataType :: UInt8 , size : 1 , }) ; } if sub as usize > 2usize { return Err (AbortCode :: NoSuchSubIndex) ; } Ok (SubInfo { access_type : zencan_common :: objects :: AccessType :: Rw , data_type : zencan_common :: objects :: DataType :: UInt32 , size : 4usize , }) } } # [derive (Debug , Default)] pub struct Object2001 { pub sub1 : AtomicCell < u32 > , pub sub3 : AtomicCell < i16 > , pub sub4 : AtomicCell < [u8 ; 12] > , } impl Object2001 { pub fn set_sub1 (& self , value : u32) { self . sub1 . store (value) } pub fn get_sub1 (& self) -> u32 { self . sub1 . load () } pub fn set_sub3 (& self , value : i16) { self . sub3 . store (value) } pub fn get_sub3 (& self) -> i16 { self . sub3 . load () } pub fn set_sub4 (& self , value : [u8 ; 12]) { self . sub4 . store (value) } pub fn get_sub4 (& self) -> [u8 ; 12] { self . sub4 . load () } } impl ObjectRawAccess for Object2001 { fn write (& self , sub : u8 , offset : usize , data : & [u8]) -> Result < () , AbortCode > { match sub { 1u8 => { if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } let value = u32 :: from_le_bytes (data . try_into () . map_err (| _ | { if data . len () < size_of :: < u32 > () { AbortCode :: DataTypeMismatchLengthLow } else { AbortCode :: DataTypeMismatchLengthHigh } }) ?) ; self . set_sub1 (value) ; Ok (()) } 3u8 => { if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } let value = i16 :: from_le_bytes (data . try_into () . map_err (| _ | { if data . len () < size_of :: < i16 > () { AbortCode :: DataTypeMismatchLengthLow } else { AbortCode :: DataTypeMismatchLengthHigh } }) ?) ; self . set_sub3 (value) ; Ok (()) } 4u8 => { if offset + data . len () > 12usize { return Err (AbortCode :: DataTypeMismatchLengthHigh) ; } self . sub4 . fetch_update (| old | { let mut new = old . clone () ; new [offset .. offset + data . len ()] . copy_from_slice (data) ; Some (new) }) ; Ok (()) } , _ => Err (AbortCode :: NoSuchSubIndex) , } } fn read (& self , sub : u8 , offset : usize , buf : & mut [u8]) -> Result < () , AbortCode > { match sub { 1u8 => { if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } if buf . len () < 4usize { return Err (AbortCode :: DataTypeMismatchLengthLow) ; } if buf . len () > 4usize { return Err (AbortCode :: DataTypeMismatchLengthHigh) ; } let value = self . get_sub1 () ; buf . copy_from_slice (& value . to_le_bytes ()) ; Ok (()) } 3u8 => { if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } if buf . len () < 2usize { return Err (AbortCode :: DataTypeMismatchLengthLow) ; } if buf . len () > 2usize { return Err (AbortCode :: DataTypeMismatchLengthHigh) ; } let value = self . get_sub3 () ; buf . copy_from_slice (& value . to_le_bytes ()) ; Ok (()) } 4u8 => { if offset + buf . len () > 12usize { return Err (AbortCode :: DataTypeMismatchLengthHigh) ; } let value = self . sub4 . load () ; buf . copy_from_slice (& value [offset .. offset + buf . len ()]) ; Ok (()) } , _ => Err (AbortCode :: NoSuchSubIndex) , } } fn sub_info (& self , sub : u8) -> Result < SubInfo , AbortCode > { match sub { 1u8 => { Ok (SubInfo { access_type : zencan_common :: objects :: AccessType :: Rw , data_type : zencan_common :: objects :: DataType :: UInt32 , size : 4usize , }) } 3u8 => { Ok (SubInfo { access_type : zencan_common :: objects :: AccessType :: Rw , data_type : zencan_common :: objects :: DataType :: Int16 , size : 2usize , }) } 4u8 => { Ok (SubInfo { access_type : zencan_common :: objects :: AccessType :: Rw , data_type : zencan_common :: objects :: DataType :: VisibleString , size : 12usize , }) } _ => Err (AbortCode :: NoSuchSubIndex) , } } } impl Default for Object2001 { fn default () -> Self { Object2001 { sub1 : AtomicCell :: new (u32 :: default ()) , sub3 : AtomicCell :: new (i16 :: default ()) , sub4 : AtomicCell :: new ([u8 ; 12] :: default ()) , } } } # [derive (Debug , Default)] pub struct Object3000 { pub value : AtomicCell < u32 > , } impl Object3000 { pub fn set_value (& self , value : u32) { self . value . store (value) ; } pub fn get_value (& self) -> u32 { self . value . load () } } impl ObjectRawAccess for Object3000 { fn write (& self , sub : u8 , offset : usize , data : & [u8]) -> Result < () , AbortCode > { if sub == 0 { if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } let value = u32 :: from_le_bytes (data . try_into () . map_err (| _ | { if data . len () < size_of :: < u32 > () { AbortCode :: DataTypeMismatchLengthLow } else { AbortCode :: DataTypeMismatchLengthHigh } }) ?) ; self . set_value (value) ; Ok (()) } else { Err (AbortCode :: NoSuchSubIndex) } } fn read (& self , sub : u8 , offset : usize , buf : & mut [u8]) -> Result < () , AbortCode > { if sub == 0 { if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } if buf . len () < 4usize { return Err (AbortCode :: DataTypeMismatchLengthLow) ; } if buf . len () > 4usize { return Err (AbortCode :: DataTypeMismatchLengthHigh) ; } let value = self . get_value () ; buf . copy_from_slice (& value . to_le_bytes ()) ; Ok (()) } else { Err (AbortCode :: NoSuchSubIndex) } } fn sub_info (& self , sub : u8) -> Result < SubInfo , AbortCode > { if sub != 0 { return Err (AbortCode :: NoSuchSubIndex) ; } Ok (SubInfo { access_type : zencan_common :: objects :: AccessType :: Rw , data_type : zencan_common :: objects :: DataType :: UInt32 , size : 4usize , }) } } # [derive (Debug , Default)] pub struct Object3003 { pub value : AtomicCell < i8 > , } impl Object3003 { pub fn set_value (& self , value : i8) { self . value . store (value) ; } pub fn get_value (& self) -> i8 { self . value . load () } } impl ObjectRawAccess for Object3003 { fn write (& self , sub : u8 , offset : usize , data : & [u8]) -> Result < () , AbortCode > { if sub == 0 { if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } let value = i8 :: from_le_bytes (data . try_into () . map_err (| _ | { if data . len () < size_of :: < i8 > () { AbortCode :: DataTypeMismatchLengthLow } else { AbortCode :: DataTypeMismatchLengthHigh } }) ?) ; self . set_value (value) ; Ok (()) } else { Err (AbortCode :: NoSuchSubIndex) } } fn read (& self , sub : u8 , offset : usize , buf : & mut [u8]) -> Result < () , AbortCode > { if sub == 0 { if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } if buf . len () < 1usize { return Err (AbortCode :: DataTypeMismatchLengthLow) ; } if buf . len () > 1usize { return Err (AbortCode :: DataTypeMismatchLengthHigh) ; } let value = self . get_value () ; buf . copy_from_slice (& value . to_le_bytes ()) ; Ok (()) } else { Err (AbortCode :: NoSuchSubIndex) } } fn sub_info (& self , sub : u8) -> Result < SubInfo , AbortCode > { if sub != 0 { return Err (AbortCode :: NoSuchSubIndex) ; } Ok (SubInfo { access_type : zencan_common :: objects :: AccessType :: Rw , data_type : zencan_common :: objects :: DataType :: Int8 , size : 1usize , }) } } # [derive (Debug , Default)] pub struct Object3004 { pub value : AtomicCell < i16 > , } impl Object3004 { pub fn set_value (& self , value : i16) { self . value . store (value) ; } pub fn get_value (& self) -> i16 { self . value . load () } } impl ObjectRawAccess for Object3004 { fn write (& self , sub : u8 , offset : usize , data : & [u8]) -> Result < () , AbortCode > { if sub == 0 { if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } let value = i16 :: from_le_bytes (data . try_into () . map_err (| _ | { if data . len () < size_of :: < i16 > () { AbortCode :: DataTypeMismatchLengthLow } else { AbortCode :: DataTypeMismatchLengthHigh } }) ?) ; self . set_value (value) ; Ok (()) } else { Err (AbortCode :: NoSuchSubIndex) } } fn read (& self , sub : u8 , offset : usize , buf : & mut [u8]) -> Result < () , AbortCode > { if sub == 0 { if offset != 0 { return Err (AbortCode :: UnsupportedAccess) ; } if buf . len () < 2usize { return Err (AbortCode :: DataTypeMismatchLengthLow) ; } if buf . len () > 2usize { return Err (AbortCode :: DataTypeMismatchLengthHigh) ; } let value = self . get_value () ; buf . copy_from_slice (& value . to_le_bytes ()) ; Ok (()) } else { Err (AbortCode :: NoSuchSubIndex) } } fn sub_info (& self , sub : u8) -> Result < SubInfo , AbortCode > { if sub != 0 { return Err (AbortCode :: NoSuchSubIndex) ; } Ok (SubInfo { access_type : zencan_common :: objects :: AccessType :: Ro , data_type : zencan_common :: objects :: DataType :: Int16 , size : 2usize , }) } } pub static OBJECT2000 : Object2000 = Object2000 :: default () ; pub static OBJECT2001 : Object2001 = Object2001 :: default () ; pub static OBJECT3000 : Object3000 = Object3000 :: default () ; pub static OBJECT3003 : Object3003 = Object3003 :: default () ; pub static OBJECT3004 : Object3004 = Object3004 :: default () ; pub static OD_TABLE : [ODEntry ; 5usize] = [ODEntry { index : 8192u16 , data : ObjectData :: Storage (& OBJECT2000) , } , ODEntry { index : 8193u16 , data : ObjectData :: Storage (& OBJECT2001) , } , ODEntry { index : 12288u16 , data : ObjectData :: Storage (& OBJECT3000) , } , ODEntry { index : 12291u16 , data : ObjectData :: Storage (& OBJECT3003) , } , ODEntry { index : 12292u16 , data : ObjectData :: Storage (& OBJECT3004) , } ,] ;
